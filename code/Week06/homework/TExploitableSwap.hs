{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Control.Monad        (mapM, unless)
import           Plutus.Model         (Ada (Lovelace), DatumMode (HashDatum),
                                       Run, Tx (..), TypedValidator (TypedValidator),
                                       FakeCoin (FakeCoin), fakeValue,
                                       UserSpend, ada, adaValue, currentTimeRad,
                                       defaultBabbage, logError, mustFail,
                                       newUser, payToKey, payToScript, spend,
                                       spendScript, submitTx, testNoErrors,wait,
                                       toV2, userSpend, utxoAt, validateIn, currentTimeInterval,
                                       valueAt, waitUntil, logInfo, currentTime, waitNSlots)
import           Plutus.V2.Ledger.Api (PubKeyHash, TxOutRef, Value)
import           PlutusTx.Prelude     (Eq ((==)), ($), (&&), (.))
import           PlutusTx.Builtins    (Integer)
import           Prelude              (IO, (<>), mconcat, show, map, fst)
import qualified ExploitableSwap      as OnChain
import           Test.Tasty           (defaultMain, testGroup)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending ,
        bad "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 100_000_000 <> scTokenVal 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scTokenVal :: Integer -> Value
scTokenVal = fakeValue (FakeCoin "Super-Cool-Token")

minAda :: Value
minAda = adaValue 1_500_000

tokenPrice :: Integer
tokenPrice = 10_000_000

type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

lockingTx :: OnChain.DatumSwap -> UserSpend -> Value -> Tx
lockingTx datum usp val =
  mconcat
    [ userSpend usp
    , payToScript swapScript (HashDatum datum) val
    ]


-- consumingTx :: OnChain.DatumSwap -> TxOutRef -> PubKeyHash -> UserSpend -> Value -> PubKeyHash -> Tx
-- consumingTx dat ref buyer buyerSpend valToBuyer seller =
--   mconcat
--     [ userSpend buyerSpend
--     , spendScript swapScript ref () dat
--     , payToKey seller $ adaValue tokenPrice
--     , payToKey buyer $ valToBuyer
--     ]

-- doubleConsumingTx :: OnChain.DatumSwap -> TxOutRef -> TxOutRef -> PubKeyHash -> UserSpend -> Value -> PubKeyHash -> Tx
-- doubleConsumingTx dat ref1 ref2 buyer buyerSpend valToBuyer seller =
--   mconcat
--     [ userSpend buyerSpend
--     , spendScript swapScript ref1 () dat
--     , spendScript swapScript ref2 () dat
--     , payToKey seller $ adaValue tokenPrice
--     , payToKey buyer $ valToBuyer
--     ]
    
consumingTx' :: OnChain.DatumSwap -> [TxOutRef] -> PubKeyHash -> UserSpend -> Value -> PubKeyHash -> Tx
consumingTx' dat refs buyer buyerSpend valToBuyer seller =
  mconcat $
    [ userSpend buyerSpend
    , payToKey seller $ adaValue tokenPrice
    , payToKey buyer valToBuyer
    ]
    <> map (\ref -> spendScript swapScript ref () dat) refs

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------
normalSpending :: Run ()
normalSpending = do

  -- SETUP USERS
  u1 <- newUser $ adaValue 20_000_000 <> scTokenVal 1
  u2 <- newUser $ adaValue 20_000_000

  -- USER 1 LOCKS 1 UTxO with 1 Fakecoin (+ 1,5 ADA) IN VALIDATOR
  let datum = OnChain.DatumSwap {
                OnChain.beneficiary = u1,
                OnChain.price       = tokenPrice
              }
  let valWithToken = minAda <> scTokenVal 1                    -- Define value to be transfered
  spU1 <- spend u1 valWithToken                        -- Get user's UTXO that we should spend
  
  submitTx u1 $ lockingTx datum spU1 valWithToken          -- User 1 submits "lockingTx" transaction
  
  -- WAIT FOR A BIT
  waitNSlots 1

  -- USER 2 TAKES 1 Fakecoin FROM VALIDATOR
  utxos <- utxoAt swapScript                -- Query blockchain to get all UTxOs at script
  --let [(ref, _)] = utxos                  -- We know there is only one UTXO (the one we created before)
  let utxoRefs = map fst utxos                  -- We know there is only one UTXO (the one we created before)
  --logError $ show utxos

  spU2 <- spend u2 $ adaValue tokenPrice
  --submitTx u2 $ consumingTx datum ref u2 spU2 valWithToken u1 -- User 2 submits "consumingTx" transaction
  submitTx u2 $ consumingTx' datum utxoRefs u2 spU2 valWithToken u1 -- User 2 submits "consumingTx" transaction

  --logError $ show $ utxoAt u2

  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  unless ( v1 == adaValue 28_500_000 && 
           v2 == adaValue 11_500_000 <> scTokenVal 1) 
    $ logError "Final balances are incorrect"
  

doubleSpending :: Run ()
doubleSpending = do

  -- SETUP USERS
  u1 <- newUser $ adaValue 20_000_000 <> scTokenVal 2
  u2 <- newUser $ adaValue 20_000_000

  -- USER 1 LOCKS 2 UTxO with 1 Fakecoin (+ 1,5 ADA) IN VALIDATOR
  let datum = OnChain.DatumSwap {
              OnChain.beneficiary = u1,
              OnChain.price       = tokenPrice
            }
  let valWithToken = minAda <> scTokenVal 1                    -- Define value to be transfered

  -- Locks 1st UTXO
  spU1 <- spend u1 valWithToken                        -- Get user's UTXO that we should spend
  submitTx u1 $ lockingTx datum spU1 valWithToken      -- User 1 submits "lockingTx" transaction
  -- WAIT FOR A BIT
  waitNSlots 1
  
  -- Locks 2nd UTXO
  spU1' <- spend u1 valWithToken                       -- Get user's UTXO that we should spend
  submitTx u1 $ lockingTx datum spU1' valWithToken      -- User 1 submits "lockingTx" transaction
  -- WAIT FOR A BIT
  waitNSlots 1

  -- USER 2 TAKES 2 Fakecoins FROM 2 UTXO in VALIDATOR
  utxos <- utxoAt swapScript                 -- Query blockchain to get all UTxOs at script
  --let [(ref1, _), (ref2, _)] = utxos                  -- We know there is 2 UTXOs
  let utxoRefs = map fst utxos                  -- We know there is only one UTXO (the one we created before)

  spU2 <- spend u2 $ adaValue tokenPrice
  let valToU2 = valWithToken <> valWithToken
  --submitTx u2 $ doubleConsumingTx datum ref1 ref2 u2 spU2 valToU2 u1   -- User 2 submits "doubleConsumingTx" transaction
  submitTx u2 $ consumingTx' datum utxoRefs u2 spU2 valToU2 u1    -- User 2 submits "doubleConsumingTx" transaction

  -- utxos2 <- utxoAt u2
  -- logError $ show utxos2

  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  unless ( v1 == adaValue 27_000_000 && 
           v2 == adaValue 13_000_000 <> scTokenVal 2) 
    $ logError "Final balances are incorrect"