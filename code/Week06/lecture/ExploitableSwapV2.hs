{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}

module ExploitableSwapV2 where

import           Plutus.V2.Ledger.Api      (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton)
import           Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo (..), TxInInfo (..), TxOut (..), findOwnInput)
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Builtins         (BuiltinData, Integer)
import           PlutusTx.Prelude          (Bool (..), (==), traceIfFalse, Maybe (Just), ($), filter, length, (&&), otherwise)
import           Utilities                 (wrapValidator)

---------------------------------------------------------------------------------------------------
----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  }
PlutusTx.unstableMakeIsData ''DatumSwap

{-# INLINABLE mkValidator #-}
mkValidator :: DatumSwap -> () -> ScriptContext -> Bool
mkValidator ds _ ctx = traceIfFalse "Hey! You have to pay the owner!" outputToBeneficiary &&
                       traceIfFalse "Swap 1 UTxO from contract per time!" onlyOneUtxoConsumed
    where
        txInfo :: TxInfo
        txInfo = scriptContextTxInfo ctx

        outputToBeneficiary :: Bool
        outputToBeneficiary = 
          valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)

        onlyOneUtxoConsumed :: Bool
        onlyOneUtxoConsumed = length comsumingUtxosFromScriptAddr == 1

        comsumingUtxosFromScriptAddr :: [TxInInfo]
        comsumingUtxosFromScriptAddr
          | Just TxInInfo{txInInfoResolved=TxOut{txOutAddress=scriptAddr}} <- findOwnInput ctx 
            = filter (matchAddr scriptAddr) (txInfoInputs $ scriptContextTxInfo ctx)
          | otherwise = []

        matchAddr addr TxInInfo{txInInfoResolved=TxOut{txOutAddress=otherAddr}} = addr == otherAddr

{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator


validator :: Validator
validator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])
